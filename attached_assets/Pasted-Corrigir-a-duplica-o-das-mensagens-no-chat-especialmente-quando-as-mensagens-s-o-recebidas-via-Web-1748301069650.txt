Corrigir a duplica√ß√£o das mensagens no chat, especialmente quando as mensagens s√£o recebidas via WebSocket. A duplica√ß√£o acontece apenas enquanto o chat est√° sendo atualizado em tempo real. Quando a p√°gina √© recarregada, a duplica√ß√£o desaparece. Precisamos garantir que as mensagens n√£o se duplicam quando o WebSocket envia dados ou quando a p√°gina √© recarregada.

1. Deduplica√ß√£o via WebSocket e API

    Use um Map para controlar as mensagens no estado e garantir que as duplica√ß√µes sejam evitadas, tanto ao enviar novas mensagens quanto ao receber mensagens via WebSocket. A chave √∫nica do Map ser√° id ou tempId das mensagens.

    Quando uma mensagem chega via WebSocket, combine as mensagens j√° recebidas da API e as mensagens em tempo real de forma a evitar duplica√ß√£o.

2. L√≥gica de Substitui√ß√£o de Mensagens Tempor√°rias

    Ao enviar uma mensagem, adicione a mensagem com um tempId tempor√°rio. Quando a confirma√ß√£o da mensagem oficial (com id real) chegar via WebSocket, substitua a mensagem tempor√°ria pela oficial.

    A l√≥gica de substitui√ß√£o de tempId deve ser feita de forma que, se a mensagem j√° foi marcada como pending e chegou uma confirma√ß√£o, ela deve ser substitu√≠da pela mensagem com o id correto, e o status deve ser atualizado para "sent" ou "delivered".

3. Uso de Map para Deduplica√ß√£o

    Ao processar as mensagens recebidas pelo WebSocket e as mensagens recebidas pela API, use um Map para armazenar as mensagens e garantir que n√£o haja duplica√ß√£o.

C√≥digo para implementar a deduplica√ß√£o:

useEffect(() => {
  if (!selectedConnectionId) return;

  let socket: WebSocket | null = null;
  let reconnectTimer: NodeJS.Timeout | null = null;

  const connectWebSocket = () => {
    try {
      const wsUrl = `wss://${window.location.host}/api/ws`;
      socket = new WebSocket(wsUrl);

      socket.onopen = () => {
        console.log(`‚úÖ WEBSOCKET CONECTADO! Conex√£o: ${selectedConnectionId}`);
        setIsConnected(true);
      };

      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          if (data.type === "newMessage" && data.data) {
            const msgData = data.data;

            // S√≥ processar se for para a conex√£o ativa
            if (msgData.connectionId === selectedConnectionId) {
              console.log(`üì® NOVA MENSAGEM: ${msgData.content} | Dire√ß√£o: ${msgData.direction}`);

              setRealtimeMessages((prev) => {
                const messagesMap = new Map();
                [...prev, ...chatMessages].forEach((msg) => {
                  const key = msg.id || msg.tempId;
                  // Priorizar mensagens com ID real sobre mensagens tempor√°rias
                  if (!messagesMap.has(key) || (msg.id && !messagesMap.get(key).id)) {
                    messagesMap.set(key, msg);
                  }
                });

                const uniqueMessages = Array.from(messagesMap.values()).sort(
                  (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
                );

                return uniqueMessages;
              });
            }
          }
        } catch (error) {
          console.error("‚ùå Erro ao processar WebSocket:", error);
        }
      };

      socket.onerror = (error) => {
        console.error("‚ùå WebSocket erro:", error);
        setIsConnected(false);
      };

      socket.onclose = () => {
        console.log("üî¥ WebSocket fechado, tentando reconectar...");
        setIsConnected(false);
        reconnectTimer = setTimeout(connectWebSocket, 3000);
      };
    } catch (error) {
      console.error("‚ùå Erro ao criar WebSocket:", error);
      reconnectTimer = setTimeout(connectWebSocket, 3000);
    }
  };

  connectWebSocket();

  return () => {
    if (reconnectTimer) clearTimeout(reconnectTimer);
    if (socket) socket.close();
  };
}, [selectedConnectionId]);

4. Status Visual da Mensagem

    Pendentes: Quando o usu√°rio envia uma mensagem, ela aparece com o √≠cone ‚è≥ e status "pending".

    Enviadas: Ap√≥s a confirma√ß√£o de envio via WebSocket, a mensagem deve ser marcada como "sent" e mudar o √≠cone para ‚úì.

    Entregues: Caso o sistema informe que a mensagem foi entregue, o status deve ser "delivered" e o √≠cone deve ser ‚úì‚úì.

    Falhas: Se a mensagem n√£o puder ser enviada, o status ser√° "failed" e o √≠cone ser√° ‚ùå.

Exemplo de implementa√ß√£o para altera√ß√£o do status:

setRealtimeMessages((prev) => 
  prev.map((msg) => 
    msg.tempId === tempId 
      ? { ...msg, status: 'sent' } // Atualiza para 'sent' quando confirmada
      : msg
  )
);

5. Teste de Funcionalidade:

    Verifique se a duplica√ß√£o foi corrigida: As mensagens devem ser exibidas uma √∫nica vez na interface, mesmo com o WebSocket atualizando constantemente.

    Confirmar o funcionamento do status visual: Envie uma mensagem, ela deve aparecer com o √≠cone ‚è≥ e ap√≥s a confirma√ß√£o, mudar para ‚úì.

    Verifique o comportamento ao atualizar a p√°gina: As mensagens devem ser recarregadas corretamente do backend sem duplica√ß√µes e os status devem ser exibidos corretamente.

    Confirmar que o status visual reflete corretamente a entrega da mensagem: Quando o WebSocket retornar que a mensagem foi entregue, o status deve mudar para ‚úì‚úì.

Conclus√£o:
Com essa implementa√ß√£o, as mensagens ser√£o exibidas corretamente, sem duplica√ß√£o, e os status de envio, falha e entrega ser√£o atualizados corretamente em tempo real. A l√≥gica de deduplica√ß√£o usando o Map garante que, mesmo com m√∫ltiplos eventos WebSocket, as mensagens n√£o se duplicam na interface, mesmo quando a p√°gina √© recarregada.