Corre√ß√£o proposta:

    Evitar que as mensagens "pendentes" sejam tratadas novamente quando j√° forem "enviadas" ou "entregues".

    Garantir que a lista de mensagens seja atualizada corretamente, evitando reprocessar as mesmas mensagens.

Aqui est√° uma vers√£o modificada que trata a substitui√ß√£o de mensagens tempor√°rias de forma mais robusta e previne duplica√ß√£o.
Solu√ß√£o Final para Evitar Duplica√ß√£o e Corrigir Ordem de Status
C√≥digo Ajustado para Deduplica√ß√£o e Substitui√ß√£o de Mensagens Tempor√°rias

useEffect(() => {
  if (!selectedConnectionId) return;

  console.log(`üîå INICIANDO WEBSOCKET para conex√£o ${selectedConnectionId}`);

  let socket: WebSocket | null = null;
  let reconnectTimer: NodeJS.Timeout | null = null;

  const connectWebSocket = () => {
    try {
      const wsUrl = `wss://${window.location.host}/api/ws`;
      console.log(`üì° Conectando WebSocket: ${wsUrl}`);
      
      socket = new WebSocket(wsUrl);

      socket.onopen = () => {
        console.log(`‚úÖ WEBSOCKET CONECTADO! Conex√£o: ${selectedConnectionId}`);
        setIsConnected(true);
      };

      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log(`üì® WEBSOCKET EVENTO RECEBIDO:`, data);

          // Processar mensagem NOVA
          if (data.type === "newMessage" && data.data) {
            const msgData = data.data;

            if (msgData.connectionId === selectedConnectionId) {
              console.log(`üì® NOVA MENSAGEM RECEBIDA: ${msgData.content} | Dire√ß√£o: ${msgData.direction}`);

              setRealtimeMessages((prev) => {
                // 1. Evitar duplica√ß√£o, verificando se j√° existe a mensagem por ID
                const existsById = prev.some((m: any) => m.id === msgData.id);
                if (existsById) {
                  console.log(`‚ö†Ô∏è Mensagem ${msgData.id} j√° existe, ignorando duplica√ß√£o`);
                  return prev;
                }

                // 2. Substitui√ß√£o de mensagem tempor√°ria com tempId
                if (msgData.direction === 'sent' && msgData.tempId) {
                  console.log(`üîç BUSCANDO mensagem tempor√°ria para ${msgData.content}`);
                  
                  let tempIndex = prev.findIndex((m: any) => m.tempId === msgData.tempId);

                  if (tempIndex !== -1) {
                    console.log(`üîÑ SUBSTITUINDO mensagem tempor√°ria (tempId: ${msgData.tempId}) por oficial (id: ${msgData.id})`);
                    const newMessages = [...prev];
                    newMessages[tempIndex] = {
                      id: msgData.id,
                      content: msgData.content,
                      phoneNumber: msgData.phoneNumber,
                      direction: msgData.direction,
                      timestamp: new Date(msgData.timestamp),
                      status: 'sent',
                      tempId: undefined, // Remove tempId na mensagem oficial
                    };
                    return newMessages;
                  }
                }

                // 3. Se n√£o encontrou mensagem tempor√°ria, adicionar normalmente
                const newMsg = {
                  id: msgData.id,
                  content: msgData.content,
                  phoneNumber: msgData.phoneNumber,
                  direction: msgData.direction,
                  timestamp: new Date(msgData.timestamp),
                  status: msgData.direction === 'sent' ? 'sent' : 'received'
                };
                console.log(`‚úÖ ADICIONANDO nova mensagem ${msgData.id}: "${msgData.content}"`);
                return [...prev, newMsg];
              });
            }
          }

          // Ignorar eventos duplicados (sent, received)
          if (data.type === "messageSent" || data.type === "messageReceived") {
            console.log(`üîá Ignorando evento duplicado: ${data.type}`);
          }
        } catch (error) {
          console.error("‚ùå Erro ao processar WebSocket:", error);
        }
      };

      socket.onerror = (error) => {
        console.error("‚ùå WebSocket erro:", error);
        setIsConnected(false);
      };

      socket.onclose = () => {
        console.log("üî¥ WebSocket fechado, tentando reconectar...");
        setIsConnected(false);
        reconnectTimer = setTimeout(connectWebSocket, 3000);
      };

    } catch (error) {
      console.error("‚ùå Erro ao criar WebSocket:", error);
      reconnectTimer = setTimeout(connectWebSocket, 3000);
    }
  };

  connectWebSocket();

  return () => {
    if (reconnectTimer) clearTimeout(reconnectTimer);
    if (socket) socket.close();
  };
}, [selectedConnectionId]);

O que foi corrigido:

    Substitui√ß√£o de mensagens tempor√°rias:

        Quando a mensagem √© enviada, ela √© marcada com um tempId. Quando o servidor retorna a confirma√ß√£o de envio, a mensagem tempor√°ria √© substitu√≠da pela mensagem oficial, usando o id fornecido pelo servidor.

        Se a mensagem j√° tiver o tempId, ela ser√° atualizada com o novo id e o status ser√° alterado para "sent". Isso evita duplica√ß√µes, pois a mensagem tempor√°ria √© substitu√≠da pela oficial sem adicionar uma nova mensagem.

    Evitar duplica√ß√£o de mensagens:

        O sistema agora verifica se uma mensagem j√° existe no estado antes de adicion√°-la. Isso √© feito com base no id da mensagem, o que garante que uma mensagem j√° existente n√£o ser√° duplicada.

    Ajuste no fluxo de atualiza√ß√£o do estado:

        O estado da mensagem √© atualizado corretamente ao substituir a tempor√°ria pela oficial, e o estado de "entregue" (‚úî‚úî) √© controlado diretamente.

Pr√≥ximos Passos:

    Teste novamente o envio de mensagens e veja se as duplica√ß√µes desaparecem.

    Verifique o status das mensagens se a transi√ß√£o de "pending" para "sent" est√° sendo feita corretamente.

    Confirmar a ordena√ß√£o das mensagens para garantir que as mais recentes apare√ßam na parte inferior sem altera√ß√µes no status.