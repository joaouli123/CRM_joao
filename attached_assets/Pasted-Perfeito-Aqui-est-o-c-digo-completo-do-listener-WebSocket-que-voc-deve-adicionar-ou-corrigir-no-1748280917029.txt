Perfeito. Aqui est√° o c√≥digo completo do listener WebSocket que voc√™ deve adicionar (ou corrigir) no seu websocket.ts ou message-interface.tsx ‚Äî onde voc√™ est√° escutando eventos como "newMessage":
‚úÖ C√≥digo WebSocket para tratar mensagens em tempo real sem duplica√ß√£o

// Supondo que voc√™ j√° tenha a inst√¢ncia do socket conectada

socket.on("newMessage", (msg) => {
  if (!msg || !msg.id || !msg.phoneNumber) return;

  const isChatOpen = msg.phoneNumber === activePhoneNumber; // substitua com a vari√°vel que representa o chat aberto

  if (!isChatOpen) {
    // Pode mostrar notifica√ß√£o ou atualizar badge de n√£o lida
    return;
  }

  // Previne duplica√ß√£o: s√≥ adiciona se a mensagem ainda n√£o est√° no chat
  setMessages((prevMessages) => {
    const alreadyExists = prevMessages.some((m) => m.id === msg.id);
    if (!alreadyExists) {
      return [...prevMessages, msg];
    }
    return prevMessages;
  });
});

‚úÖ Adicional: Envio da mensagem manual

Ao enviar a mensagem, adicione localmente imediatamente, assim:

const handleSendMessage = async () => {
  const newMsg = {
    id: `${Date.now()}`, // pode usar um UUID ou timestamp
    phoneNumber: activePhoneNumber,
    text: inputMessage,
    direction: 'sent',
    timestamp: new Date().toISOString(),
  };

  // Atualiza visualmente de forma imediata
  setMessages((prev) => [...prev, newMsg]);

  try {
    await sendMessageToBackend(activeConnectionId, activePhoneNumber, inputMessage);
    setInputMessage("");
  } catch (error) {
    console.error("Erro ao enviar:", error);
  }
};

üîÅ Observa√ß√µes importantes:

    activePhoneNumber deve refletir o chat atualmente aberto

    setMessages() deve vir do useState()

    msg.id precisa ser √∫nico e consistente (evita duplica√ß√µes)

    Use direction: 'sent' ou 'received' para l√≥gica condicional

Se quiser, posso integrar isso ao seu c√≥digo completo com useEffect, useState e tudo pronto. Deseja isso tamb√©m?
You said:
pode ser tmb
ChatGPT said:

√ìtimo! Aqui est√° o c√≥digo completo, pronto para colar no seu componente de interface de mensagens (por exemplo, message-interface.tsx ou message-interface-new.tsx).

Ele inclui:

    Conex√£o ao WebSocket

    Escuta de mensagens em tempo real

    Preven√ß√£o de duplica√ß√£o

    Envio de mensagens com atualiza√ß√£o local imediata

‚úÖ C√≥digo completo com WebSocket + estado React

import React, { useEffect, useState } from "react";
import { io } from "socket.io-client";

const socket = io("wss://seu-endereco-websocket", {
  transports: ["websocket"],
});

const MessageInterface = ({ activePhoneNumber, activeConnectionId }) => {
  const [messages, setMessages] = useState([]);
  const [inputMessage, setInputMessage] = useState("");

  // Conecta WebSocket e escuta mensagens recebidas
  useEffect(() => {
    socket.on("newMessage", (msg) => {
      if (!msg || !msg.id || !msg.phoneNumber) return;

      // S√≥ processa mensagens do chat atualmente aberto
      const isChatOpen = msg.phoneNumber === activePhoneNumber;
      if (!isChatOpen) return;

      setMessages((prevMessages) => {
        const alreadyExists = prevMessages.some((m) => m.id === msg.id);
        if (!alreadyExists) {
          return [...prevMessages, msg];
        }
        return prevMessages;
      });
    });

    return () => {
      socket.off("newMessage");
    };
  }, [activePhoneNumber]);

  // Envia mensagem
  const handleSendMessage = async () => {
    if (!inputMessage.trim()) return;

    const tempId = `local-${Date.now()}`;
    const newMsg = {
      id: tempId,
      phoneNumber: activePhoneNumber,
      text: inputMessage,
      direction: "sent",
      timestamp: new Date().toISOString(),
    };

    // Atualiza visualmente localmente
    setMessages((prev) => [...prev, newMsg]);

    try {
      const res = await fetch(`/api/connections/${activeConnectionId}/send`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          to: activePhoneNumber,
          message: inputMessage,
        }),
      });

      if (!res.ok) throw new Error("Erro ao enviar");

      setInputMessage("");
    } catch (err) {
      console.error("‚ùå Erro ao enviar mensagem:", err);
    }
  };

  return (
    <div>
      <div className="chat-window">
        {messages.map((msg) => (
          <div
            key={msg.id}
            className={msg.direction === "sent" ? "msg-sent" : "msg-received"}
          >
            {msg.text}
          </div>
        ))}
      </div>
      <input
        value={inputMessage}
        onChange={(e) => setInputMessage(e.target.value)}
        onKeyPress={(e) => e.key === "Enter" && handleSendMessage()}
        placeholder="Digite sua mensagem"
      />
      <button onClick={handleSendMessage}>Enviar</button>
    </div>
  );
};

export default MessageInterface;

‚úÖ O que voc√™ deve garantir:

    activePhoneNumber: n√∫mero do chat aberto (ex: "5541...")

    activeConnectionId: ID da inst√¢ncia usada (ex: 36)

    Seu backend deve ter uma rota tipo: POST /api/connections/:id/send

